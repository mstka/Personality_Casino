<!DOCTYPE html>
<!-- シンプルなフロントエンド -->
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ルーレット</title>
    <link rel="stylesheet" href="style.css">
    </head>
<body>
    <div class="container">
        <h1>ルーレット</h1>
        <p><a href="index.html">ホームに戻る</a></p>
        <div id="countdown" class="countdown"></div>
        <label>ベット額: <input id="amount" type="number" min="1" step="1" value="1"></label>
        <div id="board" class="board">
            <div class="overlay" id="overlay"></div>
        </div>
        <div id="options" class="options"></div>
        <div class="wheel-container">
            <div class="pointer"></div>
            <canvas id="wheel" width="300" height="300"></canvas>
        </div>
        <pre id="result"></pre>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000';

        const result = document.getElementById('result');
        const countdown = document.getElementById('countdown');
        const board = document.getElementById('board');
        const overlay = document.getElementById('overlay');
        const options = document.getElementById('options');
        const wheel = document.getElementById('wheel');
        const ctx = wheel.getContext('2d');
        const amountInput = document.getElementById('amount');
        const placedChips = [];

        const RED = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
        const WHEEL_NUMBERS = Array.from({length:37}, (_,i) => i);
        const ANGLE_STEP = 360 / WHEEL_NUMBERS.length;
        let wheelAngle = 0;

        function drawWheel(){
            const center = wheel.width/2;
            const radius = center - 10;
            ctx.clearRect(0,0,wheel.width,wheel.height);
            WHEEL_NUMBERS.forEach((num,i)=>{
                const start = (i*ANGLE_STEP-90) * Math.PI/180;
                const end = ((i+1)*ANGLE_STEP-90) * Math.PI/180;
                if(num===0) ctx.fillStyle = '#0a8f08';
                else if(RED.includes(num)) ctx.fillStyle = '#e00000';
                else ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.moveTo(center,center);
                ctx.arc(center,center,radius,start,end);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.stroke();
                ctx.save();
                ctx.translate(center,center);
                ctx.rotate(start+(end-start)/2);
                ctx.fillStyle = '#fff';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(num.toString(), radius-20,0);
                ctx.restore();
            });
        }
        drawWheel();

        function spinWheel(number){
            const index = WHEEL_NUMBERS.indexOf(number);
            const target = index * ANGLE_STEP;
            wheelAngle += 720 + (360 - target);
            wheel.style.transition = 'transform 4s cubic-bezier(0.33,1,0.68,1)';
            wheel.style.transform = `rotate(${wheelAngle}deg)`;
            setTimeout(()=>highlightCell(number),4000);
        }

        let lastSpin = null;

        function addBetCell(container, label, type, value, colorClass) {
            const cell = document.createElement('div');
            cell.textContent = label;
            cell.dataset.type = type;
            cell.dataset.value = value;
            if (colorClass) cell.classList.add(colorClass);
            cell.addEventListener('click', () => placeBet(type, value, cell));
            container.appendChild(cell);
        }

        const numCells = {};
        for (let n = 0; n <= 36; n++) {
            const cell = document.createElement('div');
            cell.textContent = n;
            cell.dataset.type = 'number';
            cell.dataset.value = n;
            if (n === 0) {
                cell.classList.add('green', 'zero');
            } else if (RED.includes(n)) {
                cell.classList.add('red');
            } else {
                cell.classList.add('black');
            }
            if (n > 0) {
                const row = Math.floor((n - 1) / 3);
                const col = (n - 1) % 3;
                cell.dataset.row = row;
                cell.dataset.col = col;
                numCells[n] = cell;
            }
            cell.addEventListener('click', () => placeBet('number', n, cell));
            board.appendChild(cell);
        }

        function spot(x, y, nums) {
            const s = document.createElement('div');
            s.className = 'bet-spot';
            s.style.left = x + 'px';
            s.style.top = y + 'px';
            s.dataset.type = 'multi';
            s.dataset.value = nums.join(',');
            s.addEventListener('click', () => placeBet('multi', s.dataset.value, s));
            overlay.appendChild(s);
        }

        const cellW = 60, cellH = 40, gap = 2, border = 4, spotSize = 16;
        for (let r = 0; r < 12; r++) {
            for (let c = 0; c < 2; c++) {
                const n1 = r * 3 + c + 1;
                const n2 = r * 3 + c + 2;
                const x = border + (c + 1) * (cellW + gap) - gap / 2 - spotSize / 2;
                const y = border + cellH + gap + r * (cellH + gap) + cellH / 2 - spotSize / 2;
                spot(x, y, [n1, n2]);
            }
        }
        for (let r = 0; r < 11; r++) {
            for (let c = 0; c < 3; c++) {
                const n1 = r * 3 + c + 1;
                const n2 = (r + 1) * 3 + c + 1;
                const x = border + c * (cellW + gap) + cellW / 2 - spotSize / 2;
                const y = border + cellH + gap + (r + 1) * (cellH + gap) - gap / 2 - spotSize / 2;
                spot(x, y, [n1, n2]);
            }
        }
        for (let r = 0; r < 11; r++) {
            for (let c = 0; c < 2; c++) {
                const nums = [
                    r * 3 + c + 1,
                    r * 3 + c + 2,
                    (r + 1) * 3 + c + 1,
                    (r + 1) * 3 + c + 2,
                ];
                const x = border + (c + 1) * (cellW + gap) - gap / 2 - spotSize / 2;
                const y = border + cellH + gap + (r + 1) * (cellH + gap) - gap / 2 - spotSize / 2;
                spot(x, y, nums);
            }
        }

        const outside = [
            ['Red', 'color', 'red', 'red'],
            ['Black', 'color', 'black', 'black'],
            ['Even', 'parity', 'even', null],
            ['Odd', 'parity', 'odd', null],
            ['1st 12', 'dozen', '1', null],
            ['2nd 12', 'dozen', '2', null],
            ['3rd 12', 'dozen', '3', null],
            ['Low', 'range', 'low', null],
            ['High', 'range', 'high', null]
        ];
        outside.forEach(o => addBetCell(options, o[0], o[1], o[2], o[3]));

        async function placeBet(type, value, cell) {
            const token = localStorage.getItem('token');
            if (!token) {
                alert('先にログインしてください');
                return;
            }
            const amount = parseFloat(amountInput.value);
            if (!amount || amount <= 0) {
                alert('金額を入力してください');
                return;
            }
            const bet = { bet_type: type, value: value, amount: amount, token: token };
            try {
                const res = await fetch(`${API_BASE}/place_bet`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(bet)
                });
                const data = await res.json();
                result.textContent = JSON.stringify(data, null, 2);
            } catch (err) {
                console.error(err);
            }
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = amount;
            cell.appendChild(chip);
            placedChips.push(chip);
        }

        function highlightCell(num) {
            document.querySelectorAll('.board div').forEach(c => c.classList.remove('highlight'));
            const el = document.querySelector(`.board div[data-value="${num}"]`);
            if (el) el.classList.add('highlight');
        }

        async function poll() {
            const token = localStorage.getItem('token');
            const url = token ? `${API_BASE}/round_status?token=${token}` : `${API_BASE}/round_status`;
            try {
                const res = await fetch(url);
                const data = await res.json();
                countdown.textContent = `次のスピンまで: ${data.time_remaining}秒`;
                if (data.time_remaining <= 5) {
                    board.classList.add('disabled');
                    options.classList.add('disabled');
                } else {
                    board.classList.remove('disabled');
                    options.classList.remove('disabled');
                }
                if (data.last_spin && (!lastSpin || lastSpin.number !== data.last_spin.number)) {
                    lastSpin = data.last_spin;
                    placedChips.forEach(c => c.remove());
                    placedChips.length = 0;
                    spinWheel(lastSpin.number);
                    result.textContent = JSON.stringify(lastSpin, null, 2);
                }
                if (data.result) {
                    result.textContent = JSON.stringify(data.result, null, 2);
                }
            } catch (err) {
                console.error(err);
            }
        }
        setInterval(poll, 1000);
        poll();
    </script>
</body>
</html>

